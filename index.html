<!doctype html>
<html lang="ko">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link
      rel="icon"
      type="image/png"
      sizes="32x32"
      href="https://babybilly.app/favicon/favicon-32x32.png"
    />
    <title>Billy Vote</title>
    <style>
      :root {
        /* Color system: neutrals + billyblue primary */
        --bg: #f5f7fb; /* app background */
        --surface: #ffffff; /* card */
        --surface-alt: #f9fbff; /* subtle tinted surface */

        --text: #1e293b; /* slate-800 */
        --muted: #64748b; /* slate-500 */

        --primary: #2d7cd2; /* billyblue500 */
        --primary-04: rgba(45, 124, 210, 0.04);
        --primary-08: rgba(45, 124, 210, 0.08);
        --primary-12: rgba(45, 124, 210, 0.12);
        --primary-20: rgba(45, 124, 210, 0.2);
        --primary-35: rgba(45, 124, 210, 0.35);
        --primary-60: rgba(45, 124, 210, 0.6);

        --success: #4cb86e;
        --danger: #e35d6a;
        --warning: #f59e0b;

        --border: rgba(15, 23, 42, 0.08);
        --shadow: 0 2px 6px rgba(2, 8, 23, 0.06);

        --chip-bg: var(--primary-08);
        --chip-text: var(--primary);
        --ring: var(--primary-35);
      }

      * {
        box-sizing: border-box;
      }
      html,
      body {
        margin: 0;
        padding: 0;
        background: var(--bg);
        color: var(--text);
        font-family:
          ui-sans-serif,
          system-ui,
          -apple-system,
          'Segoe UI',
          Roboto,
          Helvetica,
          Arial,
          'Apple Color Emoji',
          'Segoe UI Emoji';
      }

      .app {
        max-width: 960px;
        margin: 0 auto;
        min-height: 100vh;
        display: flex;
        flex-direction: column;
      }

      .header {
        position: sticky;
        top: 0;
        background: rgba(255, 255, 255, 0.75);
        backdrop-filter: saturate(180%) blur(8px);
        padding: 16px 20px 8px;
        z-index: 10;
        border-bottom: 1px solid var(--border);
      }
      .brand {
        display: flex;
        align-items: center;
        gap: 8px;
      }
      .brand-logo {
        width: 28px;
        height: 28px;
        border-radius: 8px;
        background: linear-gradient(180deg, var(--primary) 0%, #2268b3 100%);
        display: inline-flex;
        align-items: center;
        justify-content: center;
        color: white;
        font-weight: 700;
        overflow: hidden;
      }
      .brand-title {
        font-size: 20px;
        font-weight: 800;
        letter-spacing: 0.2px;
      }
      .subtle {
        color: var(--muted);
        font-size: 12px;
        margin-bottom: 4px;
        margin-top: 4px;
      }

      .content {
        flex: 1;
        padding: 8px 16px 24px;
      }

      /* Cards */
      .card {
        background: var(--surface);
        border: 1px solid var(--border);
        border-radius: 16px;
        padding: 16px;
        box-shadow: var(--shadow);
        transition:
          box-shadow 0.15s ease,
          transform 0.15s ease,
          border-color 0.15s ease;
      }
      .card:hover {
        box-shadow: 0 6px 18px rgba(2, 8, 23, 0.08);
      }

      /* Inputs/Buttons */
      .row {
        display: flex;
        align-items: center;
        gap: 10px;
        flex-wrap: wrap;
      }
      input,
      button {
        height: 42px;
        border-radius: 12px;
        border: 1px solid var(--border);
        background: #ffffff;
        color: var(--text);
        padding: 0 12px;
        font-size: 16px;
        transition:
          background-color 0.15s ease,
          color 0.15s ease,
          border-color 0.15s ease,
          box-shadow 0.15s ease,
          transform 0.06s ease;
      }
      input {
        flex: 1;
        min-width: 160px;
      }
      input::placeholder {
        color: #9aa6b2;
      }
      input:focus-visible {
        outline: 2px solid var(--ring);
        outline-offset: 2px;
        border-color: transparent;
      }
      button {
        background: var(--primary);
        color: white;
        cursor: pointer;
        border-color: transparent;
      }
      button:hover {
        background: #266dc0;
      }
      button:active {
        background: #225fa9;
        transform: translateY(1px);
      }
      button.secondary {
        background: var(--primary);
        color: white;
        border-color: transparent;
      }
      button.ghost {
        background: transparent;
        color: var(--primary);
        border-color: var(--primary-20);
      }
      button.ghost:hover {
        background: var(--primary-08);
      }
      button.danger {
        background: var(--danger);
      }
      button[disabled] {
        opacity: 1;
        cursor: not-allowed;
        background-color: var(--primary-12);
        color: var(--muted);
        border-color: var(--border);
      }
      button:focus-visible {
        outline: 2px solid var(--ring);
        outline-offset: 2px;
      }

      .grid-rooms {
        display: grid;
        gap: 12px;
        grid-template-columns: repeat(2, minmax(0, 1fr));
      }
      .room-card {
        display: grid;
        gap: 8px;
        align-content: start;
        cursor: pointer;
        transition: transform 0.08s ease;
      }
      .room-card:hover {
        transform: translateY(-2px);
      }
      .room-title {
        font-weight: 700;
        font-size: 16px;
      }
      .chip {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        padding: 6px 10px;
        border-radius: 999px;
        background: var(--chip-bg);
        color: var(--chip-text);
        font-size: 12px;
        border: 1px solid var(--primary-12);
      }

      .section-title {
        margin: 10px 0 8px;
        color: var(--muted);
        font-size: 13px;
        font-weight: 700;
      }
      .divider {
        height: 1px;
        background: var(--border);
        margin: 12px 0;
      }

      .hidden {
        display: none !important;
      }

      /* Votes */
      .votes-grid {
        display: grid;
        gap: 12px;
        grid-template-columns: repeat(2, minmax(0, 1fr));
      }
      .vote-item {
        position: relative;
        background: var(--surface);
      }
      .vote-item.full::after {
        content: '모집마감';
        position: absolute;
        inset: 0;
        background: rgba(246, 248, 255, 0.85);
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: 800;
        color: var(--text);
        font-size: 18px;
        border-radius: 16px;
        z-index: 1;
        border: 1px solid var(--primary-12);
      }
      /* rank badge when full */
      .vote-item.full::before {
        content: attr(data-rank) '위';
        position: absolute;
        top: 10px;
        right: 10px;
        z-index: 2;
        background: var(--primary);
        color: #fff;
        font-weight: 800;
        font-size: 11px;
        padding: 4px 8px;
        border-radius: 999px;
        box-shadow: 0 2px 8px var(--primary-20);
      }
      .vote-item h3 {
        margin: 0;
        font-size: 16px;
      }
      .count {
        color: var(--success);
        font-weight: 800;
      }
      .warning {
        color: var(--warning);
        font-size: 12px;
      }

      /* Footer nav (minimal) */
      .footer {
        position: sticky;
        bottom: 0;
        background: rgba(255, 255, 255);
        backdrop-filter: saturate(180%) blur(8px);
        padding: 10px 14px 16px;
        border-top: 1px solid var(--border);
        z-index: 10;
      }
      .footer .row {
        justify-content: space-between;
      }

      /* Modal-ish inline create panel */
      .create-panel {
        display: grid;
        gap: 10px;
      }

      #view-room .vote-item-row {
        border: 1px solid var(--border);
        border-radius: 12px;
        background: var(--surface-alt);
      }
      #view-room .vote-item-row .chip {
        background: transparent;
        border: hidden;
      }
      #view-room .vote-item-row button {
        height: 20px;
        width: 30px;
        font-size: 8px;
        padding: 0;
        margin: 0;
      }

      #view-room .peaples-list {
        margin-top: 8px;
      }
      #view-room .peaples-list .row {
        border: 1px solid var(--border);
        border-radius: 12px;
        background: var(--surface-alt);
      }
      #view-room .peaples-list .chip {
        background: transparent;
        border: hidden;
      }
      #view-room .peaples-list button {
        height: 20px;
        width: 30px;
        font-size: 8px;
        padding: 0;
        margin: 0;
      }
      .vote-item button {
        width: 100%;
      }
    </style>
  </head>
  <body>
    <div class="app">
      <div class="header">
        <div class="brand">
          <div class="brand-logo">
            <img src="https://babybilly.app/favicon/favicon-32x32.png" />
          </div>
          <div>
            <div class="brand-title">Billy Vote</div>
          </div>
        </div>
      </div>

      <div class="content">
        <!-- View 1: Welcome / Name -->
        <section id="view-welcome" class="card">
          <h2 style="margin: 0 0 8px">반가워요!</h2>
          <div class="subtle" style="margin-bottom: 12px">
            먼저 닉네임을 알려주세요.
          </div>
          <div class="row">
            <input id="nameInput" placeholder="닉네임" />
            <button id="goRoomsBtn">계속하기</button>
          </div>
        </section>

        <!-- View 2: Room list / create -->
        <section id="view-rooms" class="hidden">
          <div class="row" style="margin-bottom: 12px">
            <div class="card" style="flex: 1">
              <div
                class="row"
                style="justify-content: space-between; align-items: center"
              >
                <div>
                  <div class="section-title">현재 닉네임</div>
                  <div><span id="savedName" class="chip">-</span></div>
                </div>
                <button id="editNameBtn" class="secondary">이름 변경</button>
              </div>
            </div>
          </div>

          <div class="row" style="margin: 6px 0 12px">
            <button id="openCreateBtn" class="secondary">투표 만들기</button>
            <button id="refreshRoomsBtn" class="ghost">새로고침</button>
          </div>

          <div
            id="createPanel"
            class="card create-panel hidden"
            style="margin-bottom: 12px"
          >
            <div class="section-title">새로운 투표 이름</div>
            <div class="row">
              <input
                id="createRoomNameInput"
                placeholder="예: 회식 장소 투표"
              />
            </div>
            <div class="row" style="justify-content: flex-end">
              <button id="cancelCreateBtn" class="secondary">취소</button>
              <button id="confirmCreateBtn">생성</button>
            </div>
          </div>

          <div class="section-title htdden">투표 리스트</div>
          <div id="roomsGrid" class="grid-rooms"></div>
        </section>

        <!-- View 3: Room -->
        <section id="view-room" class="hidden">
          <div class="card" style="margin-bottom: 12px">
            <div class="row" style="justify-content: space-between">
              <div>
                <div class="section-title">투표 이름</div>
                <div><span id="roomKeyLabel" class="chip">-</span></div>
              </div>
              <div>
                <div class="section-title">내 역할</div>
                <div><span id="myRoleLabel" class="chip">-</span></div>
              </div>
              <div>
                <div class="section-title">시작 상태</div>
                <div><span id="ownerReadyLabel" class="chip">-</span></div>
              </div>
            </div>
          </div>

          <div
            id="ownerControls"
            class="card hidden"
            style="margin-bottom: 12px"
          >
            <h3 style="margin-top: 0">투표장 전용</h3>
            <div class="row">
              <button id="startBtn">투표 시작</button>
              <button id="stopBtn" style="background-color: gray; color: white">
                투표 완료
              </button>
              <button id="deleteRoomBtn" class="danger">투표 삭제</button>
            </div>
            <div class="divider"></div>
            <div class="row" style="margin-bottom: 8px">
              <input id="voteItemNameInput" placeholder="아이템 이름" />
              <button id="addVoteItemBtn" class="secondary">추가</button>
            </div>
            <div id="ownerItems" class="row" style="flex-wrap: wrap"></div>
          </div>

          <div class="card" style="margin-bottom: 12px">
            <h3 style="margin: 0 0 8px">
              참여자 <span id="peapleCount" class="chip">0</span>
            </h3>
            <div
              id="peaplesList"
              class="row peaples-list"
              style="flex-wrap: wrap"
            ></div>
          </div>

          <div class="card">
            <h3 style="margin: 0 0 6px">투표</h3>
            <div class="subtle" style="margin-bottom: 16px">
              투표장의 <b>시작</b> 이후부터 투표할 수 있습니다. 각 아이템은 최대
              6표까지 허용됩니다.
            </div>
            <div id="votesGrid" class="votes-grid"></div>
          </div>
        </section>
      </div>

      <div class="footer">
        <div class="row">
          <button id="navToRoomsBtn" class="secondary hidden">
            투표 리스트
          </button>
          <button id="leaveRoomBtn" class="ghost">투표 나가기</button>
        </div>
      </div>
    </div>

    <script>
      // ===== Config =====
      const GRAPHQL_HTTP_URL =
        sessionStorage.getItem('vg_http_url') ||
        'https://api.scheduling.co.kr/graphql';
      const GRAPHQL_WS_URL =
        sessionStorage.getItem('vg_ws_url') ||
        'wss://api.scheduling.co.kr/graphql';
      const VOTE_WS_URL =
        sessionStorage.getItem('vg_vote_ws_url') ||
        'wss://api.scheduling.co.kr/vote-game';
      const MAX_VOTES_PER_ITEM = 5;

      // ===== State =====
      const state = {
        view: 'welcome',
        name: sessionStorage.getItem('vg_name') || '',
        roomKey: sessionStorage.getItem('vg_roomKey') || '',
        roomId: null,
        myPeapleId: null,
        isOwner: false,
        ownerReady: false,
        peaples: new Map(), // id -> peaple
        voteItems: new Map(), // id -> voteItem
        roomsPollHandle: null,
        voteWs: null,
        voteWsConnected: false,
        voteWsToken: null,
        voteWsReconnectTimer: null,
        voteWsPingTimer: null,
      };

      // ===== Helpers: DOM =====
      const $ = (id) => document.getElementById(id);
      function showView(name) {
        state.view = name;
        ['view-welcome', 'view-rooms', 'view-room'].forEach((v) => {
          const el = $(v);
          if (!el) return;
          el.classList.toggle('hidden', v !== name);
        });
      }
      function setTopLabels() {
        $('savedName').textContent = state.name || '-';
        $('roomKeyLabel').textContent = state.roomKey || '-';
        $('myRoleLabel').textContent = state.isOwner
          ? '투표장'
          : state.myPeapleId
            ? '참가자'
            : '-';
        $('ownerReadyLabel').textContent = String(state.ownerReady);

        if (!state.ownerReady) {
          $('startBtn').classList.remove('hidden');
          $('stopBtn').classList.add('hidden');
        } else {
          $('startBtn').classList.add('hidden');
          $('stopBtn').classList.remove('hidden');
        }
      }

      // ===== Debounced refresh =====
      let refreshTimeoutId = null;
      function requestRefresh() {
        if (refreshTimeoutId) return;
        refreshTimeoutId = setTimeout(async () => {
          refreshTimeoutId = null;
          await refreshAll();
        }, 150);
      }

      // ===== GraphQL HTTP =====
      async function gqlRequest(query, variables) {
        const res = await fetch(GRAPHQL_HTTP_URL, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ query, variables }),
        });
        const json = await res.json();
        if (json.errors) {
          throw new Error(JSON.stringify(json.errors));
        }
        return json.data;
      }

      // ===== Queries/Mutations =====
      async function queryRooms() {
        const query = `
          query {
            rooms(paging: { first: 50 }) {
              edges {
                node { _id roomKey peaples { _id } }
              }
            }
          }
        `;
        const data = await gqlRequest(query, {});
        return (data.rooms.edges || []).map((e) => e.node);
      }

      async function queryRoomByKey(roomKey) {
        const query = `
          query($roomKey: String!) {
            rooms(paging: {first: 1}, filter: { roomKey: { eq: $roomKey } }) {
              edges { node { _id roomKey } }
            }
          }
        `;
        const data = await gqlRequest(query, { roomKey });
        const edges = data.rooms.edges || [];
        return edges.length ? edges[0].node : null;
      }

      async function createRoom(roomKey) {
        const mutation = `
          mutation($room: CreateRoom!) {
            createOneRoom(input: { room: $room }) { _id roomKey }
          }
        `;
        const room = { _id: String(Date.now()), roomKey };
        const data = await gqlRequest(mutation, { room });
        return data.createOneRoom;
      }

      async function createPeaple({ name, roomId, isOwner }) {
        const mutation = `
          mutation($peaple: CreatePeaple!) {
            createOnePeaple(input: { peaple: $peaple }) { _id name isOwner isReady roomId voteId }
          }
        `;
        const peaple = {
          _id: String(Date.now()),
          name,
          isOwner: !!isOwner,
          isReady: false,
          roomId: String(roomId),
        };
        const data = await gqlRequest(mutation, { peaple });
        return data.createOnePeaple;
      }

      async function ensurePeaple({ name, roomId, isOwner }) {
        try {
          return await createPeaple({ name, roomId, isOwner });
        } catch (e) {
          const query = `
            query($name: String!, $roomId: String!) {
              peaples(paging: {first: 1}, filter: { and: [ { name: { eq: $name } }, { roomId: { eq: $roomId } } ] }) {
                edges { node { _id name isOwner isReady roomId voteId } }
              }
            }
          `;
          const data = await gqlRequest(query, {
            name,
            roomId: String(roomId),
          });
          const edges = data.peaples.edges || [];
          if (edges.length) return edges[0].node;
          throw e;
        }
      }

      async function updatePeaple(id, update) {
        const mutation = `
          mutation($id: ID!, $update: UpdatePeaple!) {
            updateOnePeaple(input: { id: $id, update: $update }) { _id isReady voteId }
          }
        `;
        const data = await gqlRequest(mutation, { id: String(id), update });
        return data.updateOnePeaple;
      }

      // ===== Deletion (use existing GraphQL mutations) =====
      async function deleteOnePeaple(id) {
        const mutation = `
          mutation($id: ID!) {
            deleteOnePeaple(input: { id: $id }) { _id }
          }
        `;
        const data = await gqlRequest(mutation, { id: String(id) });
        return !!data.deleteOnePeaple;
      }
      async function deleteOneRoom(id) {
        const mutation = `
          mutation($id: ID!) {
            deleteOneRoom(input: { id: $id }) { _id }
          }
        `;
        const data = await gqlRequest(mutation, { id: String(id) });
        return !!data.deleteOneRoom;
      }

      async function deleteOneVoteItem(id) {
        const mutation = `
          mutation($id: ID!) {
            deleteOneVoteItem(input: { id: $id }) { _id }
          }
        `;
        const data = await gqlRequest(mutation, { id: String(id) });
        return !!data.deleteOneVoteItem;
      }

      async function createVoteItem({ name, roomId }) {
        const mutation = `
          mutation($voteItem: CreateVoteItem!) {
            createOneVoteItem(input: { voteItem: $voteItem }) { _id name roomId }
          }
        `;
        const voteItem = {
          _id: String(Date.now()),
          name,
          roomId: String(roomId),
        };
        const data = await gqlRequest(mutation, { voteItem });
        return data.createOneVoteItem;
      }

      async function queryVoteItems(roomId) {
        const query = `
          query($roomId: String!) {
            voteItems(paging: { first: 50 }, filter: { roomId: { eq: $roomId } }) {
              edges { node { _id name roomId } }
            }
          }
        `;
        const data = await gqlRequest(query, { roomId: String(roomId) });
        return (data.voteItems.edges || []).map((e) => e.node);
      }

      async function queryPeaples(roomId) {
        const query = `
          query($roomId: String!) {
            peaples(paging: { first: 50 }, filter: { roomId: { eq: $roomId } }) {
              edges { node { _id name isOwner isReady voteId roomId updatedAt } }
            }
          }
        `;
        const data = await gqlRequest(query, { roomId: String(roomId) });
        return (data.peaples.edges || []).map((e) => e.node);
      }

      // ===== Native WS for realtime (room scoped) =====
      function clearWsTimers() {
        if (state.voteWsReconnectTimer) {
          try {
            clearTimeout(state.voteWsReconnectTimer);
          } catch (_) {}
          state.voteWsReconnectTimer = null;
        }
        if (state.voteWsPingTimer) {
          try {
            clearInterval(state.voteWsPingTimer);
          } catch (_) {}
          state.voteWsPingTimer = null;
        }
      }

      function disconnectRoomWs() {
        clearWsTimers();
        state.voteWsToken = null;
        if (state.voteWs) {
          try {
            state.voteWs.close();
          } catch (_) {}
          state.voteWs = null;
        }
        state.voteWsConnected = false;
      }

      function connectRoomWs() {
        if (!state.roomId) return;
        // invalidate older timers
        clearWsTimers();
        // create new token for this connection attempt
        const token = Symbol('voteWs');
        state.voteWsToken = token;
        if (state.voteWs) {
          try {
            state.voteWs.close();
          } catch (_) {}
        }
        const ws = new WebSocket(VOTE_WS_URL);
        state.voteWs = ws;
        state.voteWsConnected = false;
        ws.onopen = () => {
          state.voteWsConnected = true;
          ws.send(
            JSON.stringify({
              type: 'join',
              roomId: String(state.roomId),
              name: state.name || undefined,
            }),
          );
          // start heartbeat for current token only
          state.voteWsPingTimer = setInterval(() => {
            if (state.voteWsToken !== token) return;
            try {
              ws.send(JSON.stringify({ type: 'ping' }));
            } catch (_) {}
          }, 25000);
        };
        ws.onmessage = (ev) => {
          try {
            const msg = JSON.parse(ev.data);
            if (msg.type === 'event' && msg.roomId === String(state.roomId)) {
              if (msg.event === 'refresh' || msg.event === 'presence')
                requestRefresh();
            }
          } catch (e) {
            console.warn('vote-ws parse error', e);
          }
        };
        ws.onclose = () => {
          // schedule reconnect only for the latest connection token
          if (state.voteWsToken !== token) return;
          state.voteWsConnected = false;
          if (state.voteWsReconnectTimer) return; // already scheduled
          if (state.voteWsPingTimer) {
            try {
              clearInterval(state.voteWsPingTimer);
            } catch (_) {}
            state.voteWsPingTimer = null;
          }
          state.voteWsReconnectTimer = setTimeout(() => {
            state.voteWsReconnectTimer = null;
            if (state.roomId) connectRoomWs();
          }, 1500);
        };
        ws.onerror = (e) => console.warn('vote-ws error', e);
      }
      function wsBroadcast(event, payload) {
        if (!state.voteWsConnected || !state.roomId) return;
        try {
          state.voteWs.send(
            JSON.stringify({
              type: 'broadcast',
              roomId: String(state.roomId),
              event,
              payload,
            }),
          );
        } catch (_) {}
      }

      // ===== UI renders =====
      function renderRooms(rooms) {
        const grid = $('roomsGrid');
        grid.innerHTML = '';
        for (const r of rooms) {
          const div = document.createElement('div');
          div.className = 'card room-card';
          div.innerHTML = `
            <div class="room-title">${r.roomKey}</div>
            <div class="row" style="justify-content:space-between">
              <span class="chip">인원 ${r.count}</span>
              <button class="secondary" data-join="${r._id}">입장</button>
            </div>
          `;
          grid.appendChild(div);
        }
        grid.querySelectorAll('button[data-join]').forEach((btn) => {
          btn.addEventListener('click', async (e) => {
            const roomId = e.currentTarget.getAttribute('data-join');
            const roomKey = rooms.find((x) => x._id === roomId)?.roomKey;
            if (!roomKey) return;
            await enterRoom({ roomKey, create: false });
          });
        });
      }

      function renderPeaples() {
        const list = $('peaplesList');
        list.innerHTML = '';
        const arr = Array.from(state.peaples.values()).sort((a, b) =>
          a.name.localeCompare(b.name),
        );
        const countEl = $('peapleCount');
        if (countEl) countEl.textContent = String(arr.length);
        for (const p of arr) {
          const wrap = document.createElement('div');
          wrap.className = 'row';
          const chip = document.createElement('span');
          chip.className = 'chip';
          chip.textContent = p.name + (p.isOwner ? ' (투표장)' : '');
          wrap.appendChild(chip);
          // show kick button only if I'm owner and target is not owner and not me
          if (state.isOwner && !p.isOwner && p._id !== state.myPeapleId) {
            const btn = document.createElement('button');
            btn.className = 'danger';
            btn.textContent = '강퇴';
            btn.addEventListener('click', async () => {
              if (!confirm(`정말 ${p.name} 을(를) 강퇴하시겠어요?`)) return;
              try {
                const ok = await deleteOnePeaple(p._id);
                if (!ok) return alert('강퇴 실패');
                wsBroadcast('refresh', { reason: 'kick', targetId: p._id });
                if (!state.voteWsConnected) await refreshAll();
              } catch (err) {
                console.error(err);
                alert('강퇴 실패');
              }
            });
            wrap.appendChild(btn);
          }
          list.appendChild(wrap);
        }
      }

      function computeVoteCounts() {
        const counts = {};
        for (const [id] of state.voteItems) counts[id] = 0;
        for (const p of state.peaples.values())
          if (p.voteId && counts.hasOwnProperty(p.voteId))
            counts[p.voteId] += 1;
        return counts;
      }

      function computeLastVotesByItem() {
        const result = {};
        for (const p of state.peaples.values()) {
          if (!p.voteId || !p.updatedAt) continue;
          const timeMs = new Date(p.updatedAt).getTime();
          const current = result[p.voteId];
          if (!current || timeMs > current.timeMs) {
            result[p.voteId] = { timeMs, name: p.name, peapleId: p._id };
          }
        }
        return result;
      }

      // 모집마감(6표) 순위 계산: 각 아이템별 6번째로 빠른 투표 시간 기준 오름차순
      function computeFullRanks() {
        const itemToTimes = new Map(); // itemId -> number[] (ms)
        for (const p of state.peaples.values()) {
          if (!p.voteId || !p.updatedAt) continue;
          const list = itemToTimes.get(p.voteId) || [];
          list.push(new Date(p.updatedAt).getTime());
          itemToTimes.set(p.voteId, list);
        }
        const fullItems = [];
        for (const [itemId, times] of itemToTimes.entries()) {
          if (!Array.isArray(times) || times.length < MAX_VOTES_PER_ITEM)
            continue;
          times.sort((a, b) => a - b);
          const fullTime = times[MAX_VOTES_PER_ITEM - 1];
          fullItems.push({ itemId, fullTime });
        }
        fullItems.sort((a, b) => a.fullTime - b.fullTime);
        const rankMap = {};
        fullItems.forEach((x, i) => {
          rankMap[x.itemId] = i + 1;
        });
        return rankMap; // itemId -> rank(1..)
      }

      // 같은 voteId 인원이 6명을 넘을 경우, updatedAt 기준으로 늦은 투표자(7번째 이후)에
      // 내가 포함되어 있으면 내 voteId 를 null 로 되돌린다.
      async function enforceVoteLimitAfterVote(voteId) {
        if (!state.roomId || !state.myPeapleId || !voteId) return false;
        try {
          const peaples = await queryPeaples(state.roomId);
          const voters = peaples
            .filter((p) => p.voteId === voteId && p.updatedAt)
            .sort(
              (a, b) =>
                new Date(a.updatedAt).getTime() -
                new Date(b.updatedAt).getTime(),
            );
          if (voters.length <= MAX_VOTES_PER_ITEM) return false;
          const overflow = voters.slice(MAX_VOTES_PER_ITEM);
          const iAmOverflow = overflow.some((p) => p._id === state.myPeapleId);
          if (!iAmOverflow) return false;
          await updatePeaple(state.myPeapleId, { voteId: null });
          return true;
        } catch (err) {
          console.error('enforceVoteLimitAfterVote error', err);
          return false;
        }
      }

      function renderOwnerControls() {
        const ownerPanel = $('ownerControls');
        ownerPanel.classList.toggle('hidden', !state.isOwner);
        const list = $('ownerItems');
        list.innerHTML = '';
        const items = Array.from(state.voteItems.values());
        for (const it of items) {
          const wrap = document.createElement('div');
          wrap.className = 'row vote-item-row';
          const chip = document.createElement('span');
          chip.className = 'chip';
          chip.textContent = `${it.name}`;
          const delBtn = document.createElement('button');
          delBtn.className = 'danger';
          delBtn.textContent = '삭제';
          delBtn.addEventListener('click', async () => {
            if (!confirm(`정말 '${it.name}' 아이템을 삭제하시겠어요?`)) return;
            try {
              const ok = await deleteOneVoteItem(it._id);
              if (!ok) return alert('아이템 삭제 실패');
              wsBroadcast('refresh', {
                reason: 'vote_item_deleted',
                id: it._id,
              });
              if (!state.voteWsConnected) await refreshAll();
            } catch (err) {
              console.error(err);
              alert('아이템 삭제 실패');
            }
          });
          wrap.appendChild(chip);
          wrap.appendChild(delBtn);
          list.appendChild(wrap);
        }
      }

      function renderVotes() {
        const canVote = !!state.ownerReady;
        const counts = computeVoteCounts();
        const lastByItem = computeLastVotesByItem();
        const fullRanks = computeFullRanks();
        const grid = $('votesGrid');
        grid.innerHTML = '';
        const items = Array.from(state.voteItems.values());
        for (const it of items) {
          const cnt = counts[it._id] || 0;
          const atLimit = cnt >= MAX_VOTES_PER_ITEM;
          const card = document.createElement('div');
          card.className = 'card vote-item';
          const votedThis =
            (state.peaples.get(state.myPeapleId || '') || {}).voteId === it._id;
          const lastInfo = lastByItem[it._id];

          card.innerHTML = `
						<div class="vote-item-content">
							<h3>${it.name}</h3>
							<div>현재 표: <span class="count">${cnt}</span> / ${MAX_VOTES_PER_ITEM}</div>

							${atLimit ? '<div class="warning">이 아이템은 6표에 도달했습니다.</div>' : ''}
							<div class="row voters" style="flex-wrap: wrap; margin-top: 6px; margin-bottom: 6px; min-height: 60px"></div>
							<div class="row"><button ${!canVote || atLimit ? 'disabled' : ''} data-vote="${it._id}">${votedThis ? '완료' : '투표'}</button></div>
						</div>
          `;
          // 투표자 리스트 렌더링
          const voters = Array.from(state.peaples.values())
            .filter((p) => p.voteId === it._id)
            .sort((a, b) => a.name.localeCompare(b.name));
          const votersWrap = card.querySelector('.voters');
          if (votersWrap) {
            voters.forEach((v) => {
              const chip = document.createElement('span');
              chip.className = 'chip';
              chip.textContent = v.name;
              votersWrap.appendChild(chip);
            });
          }
          // 모집마감 오버레이 및 순위 표기
          if (atLimit) {
            card.classList.add('full');
            const rank = fullRanks[it._id];
            if (rank) card.setAttribute('data-rank', String(rank));
          }
          grid.appendChild(card);
        }
        grid.querySelectorAll('button[data-vote]').forEach((btn) => {
          btn.addEventListener('click', async (e) => {
            const voteId = e.currentTarget.getAttribute('data-vote');
            if (!state.myPeapleId) return alert('먼저 투표에 입장하세요.');
            try {
              await updatePeaple(state.myPeapleId, { voteId });
              const reverted = await enforceVoteLimitAfterVote(voteId);
              wsBroadcast('refresh', {
                reason: reverted ? 'vote_reverted_overflow' : 'vote_changed',
              });
              if (!state.voteWsConnected) await refreshAll();
            } catch (err) {
              console.error(err);
              alert('투표 실패');
            }
          });
        });
      }

      function fullRender() {
        setTopLabels();
        renderPeaples();
        renderOwnerControls();
        renderVotes();
      }

      // ===== Actions =====
      async function refreshAll() {
        if (!state.roomId) return;
        const [peaples, voteItems] = await Promise.all([
          queryPeaples(state.roomId),
          queryVoteItems(state.roomId),
        ]);
        state.peaples.clear();
        peaples.forEach((p) => state.peaples.set(p._id, p));
        state.voteItems.clear();
        voteItems.forEach((v) => state.voteItems.set(v._id, v));

        // derive my info
        if (state.myPeapleId && state.peaples.has(state.myPeapleId)) {
          state.isOwner = !!state.peaples.get(state.myPeapleId).isOwner;
        } else if (state.name) {
          const me = peaples.find((p) => p.name === state.name);
          if (me) {
            state.myPeapleId = me._id;
            sessionStorage.setItem(
              `vg_peapleId_${state.roomId}`,
              state.myPeapleId,
            );
            state.isOwner = !!me.isOwner;
          }
        }
        const owner = peaples.find((p) => p.isOwner);
        state.ownerReady = owner ? !!owner.isReady : false;

        fullRender();
      }

      async function loadRoomsList() {
        const rooms = await queryRooms();
        const enriched = rooms.map((r) => ({
          ...r,
          count: Array.isArray(r.peaples) ? r.peaples.length : 0,
        }));
        renderRooms(enriched);
      }

      async function enterRoom({ roomKey, create }) {
        if (!state.name) return alert('닉네임을 먼저 입력하세요.');
        try {
          let room = await queryRoomByKey(roomKey);
          if (!room) {
            if (!create) return alert('존재하지 않는 투표입니다.');
            room = await createRoom(roomKey);
          }
          state.roomKey = room.roomKey;
          state.roomId = room._id;
          sessionStorage.setItem('vg_roomKey', state.roomKey);
          sessionStorage.setItem(
            `vg_roomId_for_${state.roomKey}`,
            state.roomId,
          );

          const peaple = await ensurePeaple({
            name: state.name,
            roomId: room._id,
            isOwner: !!create,
          });
          state.myPeapleId = peaple._id;
          state.isOwner = !!peaple.isOwner;
          sessionStorage.setItem(
            `vg_peapleId_${state.roomId}`,
            state.myPeapleId,
          );

          setTopLabels();
          await refreshAll();
          connectRoomWs();
          showView('view-room');
          // Presence 이벤트가 WS로 전파되므로 별도 refresh 브로드캐스트는 생략
        } catch (err) {
          console.error(err);
          alert('입장/생성 중 오류가 발생했습니다.');
        }
      }

      async function onAddVoteItem() {
        const name = $('voteItemNameInput').value.trim();
        if (!name) return;
        if (!state.roomId) return alert('먼저 투표에 입장하세요.');
        try {
          await createVoteItem({ name, roomId: state.roomId });
          wsBroadcast('refresh', { reason: 'vote_item_created' });
          $('voteItemNameInput').value = '';
          if (!state.voteWsConnected) await refreshAll();
        } catch (err) {
          console.error(err);
          alert('아이템 추가 실패');
        }
      }

      async function onStart() {
        if (!state.isOwner) return alert('투표장만 시작할 수 있습니다.');
        if (!state.myPeapleId)
          return alert('내 Peaple ID를 확인할 수 없습니다.');
        try {
          await updatePeaple(state.myPeapleId, { isReady: true });
          wsBroadcast('refresh', { reason: 'owner_ready' });
          if (!state.voteWsConnected) await refreshAll();
        } catch (err) {
          console.error(err);
          alert('시작 처리 실패');
        }
      }
      async function onStop() {
        if (!state.isOwner) return alert('투표장만 멈출 수 있습니다.');
        if (!state.myPeapleId)
          return alert('내 Peaple ID를 확인할 수 없습니다.');
        try {
          await updatePeaple(state.myPeapleId, { isReady: false });
          wsBroadcast('refresh', { reason: 'owner_stop' });
          if (!state.voteWsConnected) await refreshAll();
        } catch (err) {
          console.error(err);
          alert('멈춤 처리 실패');
        }
      }

      // ===== Events =====
      $('goRoomsBtn').addEventListener('click', async () => {
        const val = $('nameInput').value.trim();
        if (!val) return alert('닉네임을 입력해주세요.');
        state.name = val;
        sessionStorage.setItem('vg_name', state.name);
        $('savedName').textContent = state.name;
        showView('view-rooms');
        await loadRoomsList();
      });

      $('editNameBtn').addEventListener('click', () => {
        showView('view-welcome');
        $('nameInput').value = state.name || '';
      });
      $('refreshRoomsBtn').addEventListener('click', loadRoomsList);
      $('openCreateBtn').addEventListener('click', () =>
        $('createPanel').classList.remove('hidden'),
      );
      $('cancelCreateBtn').addEventListener('click', () =>
        $('createPanel').classList.add('hidden'),
      );
      $('confirmCreateBtn').addEventListener('click', async () => {
        const key = $('createRoomNameInput').value.trim();
        if (!key) return;
        $('createPanel').classList.add('hidden');
        await enterRoom({ roomKey: key, create: true });
      });

      $('addVoteItemBtn').addEventListener('click', onAddVoteItem);
      $('startBtn').addEventListener('click', onStart);
      $('stopBtn').addEventListener('click', onStop);
      $('deleteRoomBtn').addEventListener('click', async () => {
        if (!state.isOwner) return alert('투표장만 삭제할 수 있습니다.');
        if (!state.roomId) return alert('투표 정보를 확인할 수 없습니다.');
        if (
          !confirm('정말 이 투표를 삭제하시겠어요? 모든 데이터가 사라집니다.')
        )
          return;
        try {
          const ok = await deleteOneRoom(state.roomId);
          if (!ok) return alert('투표 삭제 실패');
          try {
            wsBroadcast('refresh', { reason: 'room_deleted' });
          } catch (_) {}
          // reset local state
          state.roomId = null;
          state.roomKey = '';
          state.myPeapleId = null;
          state.isOwner = false;
          state.ownerReady = false;
          state.peaples.clear();
          state.voteItems.clear();
          sessionStorage.removeItem('vg_roomKey');
          showView('view-rooms');
          await loadRoomsList();
        } catch (err) {
          console.error(err);
          alert('투표 삭제 실패');
        }
      });
      $('navToRoomsBtn').addEventListener('click', async () => {
        showView('view-rooms');
        await loadRoomsList();
      });
      $('leaveRoomBtn').addEventListener('click', () => {
        disconnectRoomWs();
        showView('view-rooms');
      });

      // ===== Init =====
      (function init() {
        $('nameInput').value = state.name || '';
        $('savedName').textContent = state.name || '-';
        if (state.name) {
          showView('view-rooms');
          loadRoomsList();
        } else {
          showView('view-welcome');
        }
      })();
    </script>
  </body>
</html>
